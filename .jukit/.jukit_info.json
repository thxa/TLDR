{"cmd": "\nfrom ortools.constraint_solver import routing_enums_pb2\nfrom ortools.constraint_solver import pywrapcp\nimport numpy as np\n\n# Extract customer locations (including a depot)\ndepot = (21.501795, 39.244198)  # Replace with actual depot location\ncustomer_locations = customer_data[['Latitude', 'Longitude']].values.tolist()\nlocations = [depot] + customer_locations  # Depot + all customer locations\n\n# Vehicle properties\nnum_vehicles = len(truck)  # Number of vehicles\nvehicle_capacities = truck['Capacity (Pallets)'].astype(int).tolist()\n\n# Customer demands (including depot with 0 demand)\ndemands = [0] + customer_data['demand'].tolist()\n\n# Calculate Euclidean distance between locations (distance matrix)\ndef compute_euclidean_distance_matrix(locations):\n    distances = np.zeros((len(locations), len(locations)))\n    for i, loc1 in enumerate(locations):\n        for j, loc2 in enumerate(locations):\n            if i != j:\n                distances[i][j] = np.sqrt((loc1[0] - loc2[0]) ** 2 + (loc1[1] - loc2[1]) ** 2)\n    return distances\n\n\ndistance_matrix = compute_euclidean_distance_matrix(locations)\n\n# Create the routing model\nmanager = pywrapcp.RoutingIndexManager(len(distance_matrix), num_vehicles, 0)  # Depot index is 0\nrouting = pywrapcp.RoutingModel(manager)\n\n\n# Create and register a transit callback (distance)\ndef distance_callback(from_index, to_index):\n    from_node = manager.IndexToNode(from_index)\n    to_node = manager.IndexToNode(to_index)\n    return distance_matrix[from_node][to_node]\n\n\ntransit_callback_index = routing.RegisterTransitCallback(distance_callback)\nrouting.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)\n\n\n# Add capacity constraint\ndef demand_callback(from_index):\n    from_node = manager.IndexToNode(from_index)\n    return demands[from_node]\n\n\ndemand_callback_index = routing.RegisterUnaryTransitCallback(demand_callback)\nrouting.AddDimensionWithVehicleCapacity(\n    demand_callback_index,  # demand callback\n    0,  # null capacity slack\n    vehicle_capacities,  # vehicle capacities\n    True,  # start cumul to zero\n    'Capacity'\n)\n\n# Set search parameters\nsearch_parameters = pywrapcp.DefaultRoutingSearchParameters()\nsearch_parameters.first_solution_strategy = routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC\n\n# Solve the problem\nsolution = routing.SolveWithParameters(search_parameters)\n\n# Print the solution\nif solution:\n    for vehicle_id in range(num_vehicles):\n        index = routing.Start(vehicle_id)\n        route_distance = 0\n        route_load = 0\n        route = []\n        while not routing.IsEnd(index):\n            node_index = manager.IndexToNode(index)\n            route_load += demands[node_index]\n            route.append(node_index)\n            previous_index = index\n            index = solution.Value(routing.NextVar(index))\n            route_distance += routing.GetArcCostForVehicle(previous_index, index, vehicle_id)\n        route.append(manager.IndexToNode(index))\n        print(f\"Route for vehicle {vehicle_id}: {route}\")\n        print(f\"Distance of the route: {route_distance}\")\n        print(f\"Load of the route: {route_load}\")\nelse:\n    print('No solution found!')", "cmd_opts": " --cell_id=u5xlp5o3Yo -s", "import_complete": 1, "terminal": "nvimterm"}